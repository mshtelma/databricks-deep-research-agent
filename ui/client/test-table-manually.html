<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Table Rendering Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        #streaming-content {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            min-height: 100px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 14px;
        }
        #rendered-content {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-height: 100px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 10px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            background: #e3f2fd;
            color: #1976d2;
        }
        .error {
            background: #ffebee;
            color: #c62828;
        }
        .success {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .placeholder {
            background: #fff3e0;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            border: 1px dashed #ff9800;
            color: #e65100;
        }
    </style>
</head>
<body>
    <h1>Table Rendering Test</h1>
    
    <div class="container">
        <h2>Controls</h2>
        <button id="startBtn" onclick="startStream()">Start Streaming</button>
        <button id="stopBtn" onclick="stopStream()" disabled>Stop</button>
        <button id="clearBtn" onclick="clearContent()">Clear</button>
        <div id="status" class="status">Ready to test table streaming</div>
    </div>

    <div class="container">
        <h2>Raw Streaming Content</h2>
        <div id="streaming-content"></div>
    </div>

    <div class="container">
        <h2>Buffered & Rendered Content</h2>
        <div id="rendered-content"></div>
    </div>

    <script>
        let eventSource = null;
        let accumulatedContent = '';
        let tableBuffer = {
            inTable: false,
            tableStartIndex: -1,
            tableLines: [],
            currentBuffer: ''
        };

        function isTableStart(line, nextLine) {
            const trimmed = line.trim();
            if (trimmed.startsWith('|') && trimmed.endsWith('|')) {
                const pipeCount = (trimmed.match(/\|/g) || []).length;
                if (pipeCount >= 3) {
                    if (nextLine) {
                        const nextTrimmed = nextLine.trim();
                        if (nextTrimmed.match(/^\|?\s*[:?\-]+\s*(\|\s*[:?\-]+\s*)*\|?\s*$/)) {
                            return true;
                        }
                    }
                    return true;
                }
            }
            return false;
        }

        function isTableSeparator(line) {
            const trimmed = line.trim();
            return !!(
                trimmed.match(/^\|?\s*[:?\-]+\s*(\|\s*[:?\-]+\s*)*\|?\s*$/) ||
                trimmed.match(/^\|(\s*:?-+:?\s*\|)+\s*$/) ||
                (trimmed.match(/^[\|\s\-:]+$/) && trimmed.includes('-') && trimmed.includes('|'))
            );
        }

        function isTableRow(line) {
            const trimmed = line.trim();
            return trimmed.includes('|') && (
                (trimmed.startsWith('|') && trimmed.endsWith('|')) ||
                isTableSeparator(line)
            );
        }

        function processStreamingContent(content) {
            const lines = content.split('\n');
            const outputLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const nextLine = lines[i + 1];
                
                if (!tableBuffer.inTable) {
                    if (isTableStart(line, nextLine)) {
                        tableBuffer.inTable = true;
                        tableBuffer.tableStartIndex = outputLines.length;
                        tableBuffer.tableLines = [line];
                        outputLines.push('<div class="placeholder">ðŸ“Š Receiving table data...</div>');
                    } else {
                        outputLines.push(line);
                    }
                } else {
                    if (isTableRow(line) || isTableSeparator(line)) {
                        tableBuffer.tableLines.push(line);
                    } else if (line.trim() === '') {
                        let tableContinues = false;
                        for (let j = i + 1; j < Math.min(i + 3, lines.length); j++) {
                            if (lines[j] && isTableRow(lines[j])) {
                                tableContinues = true;
                                break;
                            }
                        }
                        
                        if (tableContinues) {
                            tableBuffer.tableLines.push(line);
                        } else {
                            const completeTable = tableBuffer.tableLines.join('\n');
                            outputLines[tableBuffer.tableStartIndex] = completeTable;
                            tableBuffer.inTable = false;
                            tableBuffer.tableLines = [];
                            tableBuffer.tableStartIndex = -1;
                            outputLines.push(line);
                        }
                    } else {
                        const completeTable = tableBuffer.tableLines.join('\n');
                        outputLines[tableBuffer.tableStartIndex] = completeTable;
                        tableBuffer.inTable = false;
                        tableBuffer.tableLines = [];
                        tableBuffer.tableStartIndex = -1;
                        outputLines.push(line);
                    }
                }
            }
            
            return outputLines.join('\n');
        }

        function renderMarkdownTable(text) {
            // Simple markdown table to HTML conversion
            const lines = text.split('\n');
            let html = '';
            let inTable = false;
            let tableHtml = '';
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                if (trimmed.startsWith('|') && trimmed.endsWith('|')) {
                    if (!inTable) {
                        inTable = true;
                        tableHtml = '<table>';
                    }
                    
                    if (isTableSeparator(line)) {
                        // Skip separator rows
                        continue;
                    }
                    
                    const cells = trimmed.slice(1, -1).split('|').map(c => c.trim());
                    const isHeader = i === 0 || (i > 0 && isTableSeparator(lines[i + 1]));
                    
                    tableHtml += '<tr>';
                    for (const cell of cells) {
                        const cleanCell = cell.replace(/\*\*/g, '');
                        if (isHeader) {
                            tableHtml += `<th>${cleanCell}</th>`;
                        } else {
                            tableHtml += `<td>${cleanCell}</td>`;
                        }
                    }
                    tableHtml += '</tr>';
                } else {
                    if (inTable) {
                        tableHtml += '</table>';
                        html += tableHtml;
                        tableHtml = '';
                        inTable = false;
                    }
                    
                    if (line.includes('<div class="placeholder">')) {
                        html += line;
                    } else {
                        html += `<p>${line}</p>`;
                    }
                }
            }
            
            if (inTable) {
                tableHtml += '</table>';
                html += tableHtml;
            }
            
            return html;
        }

        function startStream() {
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('status').textContent = 'Connecting...';
            document.getElementById('status').className = 'status';
            
            accumulatedContent = '';
            tableBuffer = {
                inTable: false,
                tableStartIndex: -1,
                tableLines: [],
                currentBuffer: ''
            };
            
            eventSource = new EventSource('http://localhost:8000/api/api/test/table-stream');
            
            eventSource.onopen = function() {
                document.getElementById('status').textContent = 'Connected - streaming table content...';
                document.getElementById('status').className = 'status success';
            };
            
            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);
                
                if (data.type === 'content_delta' && data.content) {
                    accumulatedContent += data.content;
                    
                    // Display raw content
                    document.getElementById('streaming-content').textContent = accumulatedContent;
                    
                    // Process and render buffered content
                    const buffered = processStreamingContent(accumulatedContent);
                    const rendered = renderMarkdownTable(buffered);
                    document.getElementById('rendered-content').innerHTML = rendered;
                } else if (data.type === 'message_complete') {
                    // Finalize any buffered tables
                    if (tableBuffer.inTable && tableBuffer.tableLines.length > 0) {
                        const buffered = processStreamingContent(accumulatedContent);
                        const rendered = renderMarkdownTable(buffered);
                        document.getElementById('rendered-content').innerHTML = rendered;
                    }
                    
                    document.getElementById('status').textContent = 'Streaming complete!';
                    document.getElementById('status').className = 'status success';
                    stopStream();
                } else if (data.type === 'stream_end') {
                    stopStream();
                }
            };
            
            eventSource.onerror = function(error) {
                console.error('Stream error:', error);
                document.getElementById('status').textContent = 'Error: Connection failed';
                document.getElementById('status').className = 'status error';
                stopStream();
            };
        }

        function stopStream() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        function clearContent() {
            document.getElementById('streaming-content').textContent = '';
            document.getElementById('rendered-content').innerHTML = '';
            document.getElementById('status').textContent = 'Ready to test table streaming';
            document.getElementById('status').className = 'status';
            accumulatedContent = '';
            tableBuffer = {
                inTable: false,
                tableStartIndex: -1,
                tableLines: [],
                currentBuffer: ''
            };
        }
    </script>
</body>
</html>